---
layout: post
title:  "CS 112: Data Structures Notes"
date:   2015-09-08
categories: CS112, Java
---
#Day 2 Notes
Programming languages have two types of techniques to pass arguments:
Pass/Call by value

{% highlight java %}
Class Cat{
	String name;
	
	Public Cat (String name) { 
		this.name = name; } }
		
Static void foo(Cat d) {
	d.name = "Baloo"; // c
	d = new Cat("Lilo"); } //d
	
Static main(String args[]){
	Cat aCat = new Cat("Foo"); //a
	Cat.Foo(aCat); } //b
	
{% endhighlight %}

Java CBV

//a

`Flo`<sub>42</sub>

`aCat[42]`<sub>40</sub>  --> `Flo`<sub>42</sub>

//b

`foo(aCat)`

--after call
`d[42]`<sub>46</sub>  --> `Flo`<sub>42</sub>  //main is calling foo which is the callee

--inside foo
`d[42]`<sub>46</sub>  --> `Baloo`<sub>42</sub> //changed c

`d[42]`<sub>46</sub>  --> `Lilo`<sub>48</sub>

//b

`d[42]`<sub>46</sub>  --> `Baloo`<sub>42</sub>

because we call a constructor inside a method, we lose that when we go back to main

in `C` , you can call by reference with ampersand

//a
aCat [42] @ 40  --> [Flo] @ 42

//b
foo(aCat)
--after call
d [40] @ 46 -->[aCat] @ 40 --> [Flo] @ 42 //main is calling foo which is the callee

--inside foo
d [40] @ 46 -->[aCat] @ 40 --> [Baloo] @ 42  //changed c

d [40] @ 46 -->[aCat] @ 40 --> [Lilo] @ 48 // d

//b
aCat [42] @ 40  --> [Lilo] @ 48	

----------------------------------------------------

Linked Lists

Node @ current address
[data, link to the next node]

{% highlight bash %}
int nodes:
locat:   2		5				9					11
[int a, 5]		[int b, 9] 	[int c, 11] 		[int d, null]  	//null signifies end of node list
{% endhighlight %}

Linked Lists can only be transversed forward

Doubly linked lists have 3 member fields
[int a, previous memory address, next memory address]

//circular linked lists


{% highlight java %}
Class IntNode{								
	int Data;										//should be able to make generic 
	intNode next; }								//for doubly linked lists, you can just add intNode previous;
	
Public IntNode(int data, intNode next) {
	this.data = data;
	this.next = next; }
	
Static main(){
	intNode L = null;										// a
	intNode node1 = new intNode(3, null);		// b
	l = node1;												// c
	intNode node2 - new intNode (5,null);		// d
	node1.next = node2; 								// e	 Last in first out, no need to create initial node
	intNode node3 = new intNode(7,null);		// 	f
	node2.next = node3; 								// g
	intNode nextNode =L;		}						// h
	
	
Static Traverse(intNode nextNode){
	while(nextNode.next != null) {
		System.out.println(intNode.int val);
		nextNode = nextNode.next; } }
		
{% endhighlight %}

//a

`L[null]`<sub>72</sub>

//b

`node1[3, null]`<sub>76</sub>

80, node2 
120








#Day 1 Notes

| Grading ||
|:-----|:-----:|
|Assignments (5) | 35% |
|Midterm 1 | 15% |
|Midterm 2 | 15% |
|Final | 35%|
|Recitation hw (5 total)| 5%|

Data Structures:

|Linear|Trees|Graphs|Hash Table|
|Array|Binary Tree|Undirected| |
|Linked List|Binary Search Tree|Directed| |
|Stack|AVL Tree|Weighted| |
|Queue|Heap| | |

Searching:

- Array
- Linked List
- Sorted Array 
- Binary Search Tree 
- AVL Tree 
- Hash Table

Graph Algorithms:

- DFS (Depth first search)
- BFS (Breadth first search)
- Topological Sorting
- Shortest Paths

Sorting:

|Array|Linked List| Heap|
|:----|:-----:|:----|
|Insertion Sort    |Mergesort   |Heapsort|
|Quicksort| Radixsort(time permitting)| |

<br>
Big O:
`Worst Case` `Best Case` `Average Case`

Eclipse IDE

----------------------------
drew a ladder, memory is a bunch of bytes...
H  <--- pointer to memory(for example an array)
H 
H
H

Google, Graphs (for maps.. )
	connection of nodes
	
I can't see
something about dog, new dog
pass by value vs pass by reference

Java passes by Value 
Object references are passed by value
a copy of the object being referenced is passed as a value

so does making it static "fix" this problem?
-------------
Linked Lists
Lisp, car cdr

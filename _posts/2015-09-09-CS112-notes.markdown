---
layout: post
title:  "CS 112: Data Structures Notes"
date:   2015-09-09
categories: CS112
---
#Day 3

{% highlight java %}
class IntNode{
	int data;
	IntNode next; 
	
	public intNode(int dataIn, IntNode next){
		this.data = dataIn;
		this.next = next; }
	

static IntNode prefix(int data, IntNode currFront) {
	IntNode node = new IntNode(data, currFront); //need to specify front since not double linked
	return node;}
	

static void traverse(IntNode currFront){
	IntNode temp = curFront;
	while(temp =! null) {
		System.out.println(temp.data);
		curFront = curFront.next; } } //null pointer exception?


static IntNode deleteFirst(IntNode currFront){
	curFront = curFront.next; }


static IntNode deleteGenetic(...){
	tempP.next = temp.next; } //can overload delete for first vs generic


static void addAfter(IntNode beginning, int dataPresent, int dataToAdd){
	IntNode tempNode = beginning;

	while(tempNode =! null) {
			if(tempNode ==  dataPresent) { break;}
			else {tempNode = tempNode.next;} }

	intNode node = new IntNode(2, null);
	node.next = tempNode.next;
	tempNode.next = node; }
	

static main(){
	IntNode initialL = null;
	IntNode node1 = new IntNode(3, null); //IntNode node1 = new IntNode(3, null);
	initialL = node1;
	IntNode node2 = new IntNode(5, null); 
	initialL.next = node1;
	initialL = prefix(0, initialL);
}
	
{% endhighlight %}

{% highlight java %}

{% endhighlight %}

Problem Set 1

Spreadsheet: r students, c tests; find total score/student, find avg score/exam


Pass by value means you have to return a modified pointer if you want to keep it. When you have a method call and then modify a pointer (reference), you will lose that modification
unless you return it back to the caller. 

Q:

Common pool for strings

`String S1 = "Hello";`

vs

`String S2 = new String("Hello");`

in first case, it goes to the common pool.
in second case it goes onto the heap.

if you add

`String S3 = "Hello";`

it points again to the object created in common pool

`String S4 = new String("Hello");`

this creates a third object, that can be found inside the heap

`S1 == S2 evaluates to false`

`S1.equals(S2) evaluates to true`

`S1 == S3 evaluates to true`

When making a linked list with strings, both member fields will contain references. one to string contained in the node, and the other part points to next

only primitives can be held inside nodes.




Does using 2 indexes vs using 1 make a big difference?
Traverse vs toStrings
can you have an array that's linked by nodes? 
assignment 1?